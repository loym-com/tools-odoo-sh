#!/usr/bin/env bash

project_root=$(python3 -c "import settings; print(settings.project_root)")
project_branch=$(python3 -c "import settings; print(settings.project_branch)")

set -e

help-table() {
    local cmd_width=55
    local desc_width=50
    local column="| %-${cmd_width}s | %-${desc_width}s |\n"

    printf "$column" "Command" "Description"
    echo "|$(printf '%*s' $((cmd_width + 2)) '' | tr ' ' '-')|$(printf '%*s' $((desc_width + 2)) '' | tr ' ' '-')|"

    printf "$column" "help [grep]" "Show help for commands."
    printf "$column" "git_henrik" "Configure Henrik's global Git settings."
    printf "$column" "submodules" "List all submodules"
    printf "$column" "update" "Update all submodules and push $project_branch branch."
    printf "$column" "update_all_submodules" "Update all submodules (recursively)."
    printf "$column" "update_submodule <name>" "Update a single submodule."
    printf "$column" "add_submodule <user> <repo> <branch>" "Add a Git submodule."
    printf "$column" "add_module <submodule> <module>" "Symlink a module from a submodule."
    printf "$column" "remove_module <submodule> <module>" "Remove symlinked module."
    printf "$column" "remove_submodule <submodule>" "Remove a Git submodule."
    printf "$column" "add_beta_module <user> <repo> <branch> <module> <dir>" "Add a 'beta' module."
    printf "$column" "add_fix_module <user> <rrep> <branch> <module> <dir>" "Add a 'fix' module."
    printf "$column" "remove_beta_module <submodule> <module>" "Remove beta module + submodule."
    printf "$column" "remove_fix_module <submodule> <module>" "Remove fix module + submodule."
}

help() {
    echo
    if [[ -n "$1" ]]; then
        help-table | grep -i "$1" | column -t -s'|'
    else
        echo "task <command> [options]"
        echo
        echo "commands:"
        echo
        help-table
    fi
    echo
}

###########################################################

# DO FIRST TIME

git_henrik() {
    git config --global user.email "henrik@loym.com"
    git config --global user.name "Henrik Norlin"
    mkdir -p ~/.ssh
}

# SHOW SUBMODULES

submodules() {
    local GITMODULES_FILE="$project_root/.gitmodules"

    if [[ ! -f "$GITMODULES_FILE" ]]; then
        echo "Error: $GITMODULES_FILE not found."
        return 1
    fi

    echo "Available submodules:"
    echo

    # POSIX-compatible awk parsing
    awk '
        /^\[submodule / {
            # Extract name manually
            n = index($0,"\"")
            if (n > 0) {
                line = substr($0,n+1)
                m = index(line,"\"")
                if (m > 0) name = substr(line,1,m-1)
            }
        }
        /^[[:space:]]*url[[:space:]]*=/ {
            url = $0
            sub(/^[[:space:]]*url[[:space:]]*=[[:space:]]*/, "", url)
        }
        /^[[:space:]]*branch[[:space:]]*=/ {
            branch = $0
            sub(/^[[:space:]]*branch[[:space:]]*=[[:space:]]*/, "", branch)
            print name "|" url "|" branch
        }
    ' "$GITMODULES_FILE" | sort | \
    while IFS='|' read -r name url branch; do
        https_url="${url/git@github.com:/https://github.com/}"
        https_url="${https_url/.git/}/tree/${branch}"
        printf "  %-30s %s\n" "$name" "$https_url"
    done
}

# UPDATE

update() {
    update_all_submodules
    git push --set-upstream origin $project_branch
}

update_all_submodules() {
    _do_first
    git submodule update --init --remote && \
    git commit -am "git submodule update"
}

update_submodule() {
    _do_first
    submodule=$1
    path="$(_get_submodule_path $submodule)"

    git submodule update --init --remote $path && \
    git commit -am "git submodule update $path"
}

# STANDARD

add_submodule() {
    _do_first
    gh_user=$1
    gh_repo=$2
    gh_branch=$3
    submodule_name="${4:-$(_get_default_submodule_name $gh_user $gh_repo)}"
    submodule_path="${5:-$(_get_default_submodule_path $gh_user $gh_repo)}"
    url=$(_get_url $gh_user $gh_repo)

    git clone --depth 1 -b $gh_branch $url $submodule_path && \
    git submodule add --depth 1 --name $submodule_name -b $gh_branch $url $submodule_path && \
    git add --all && \
    git commit -m "Added $submodule_path"
}

add_module() {
    _do_first
    submodule=$1
    module=$2
    path=$(_get_submodule_path $submodule)
    _check_submodule_path $path
    IFS='/' read -r dir1 dir2 dir3 <<< "$path"
    ln_link="$dir1/$dir2/$module"
    ln_target=$dir3/$module

    ln -s $ln_target $ln_link && \
    git add --all && \
    git commit -m "Added module $ln_link"
}

remove_module() {
    _do_first
    submodule=$1
    module=$2
    path=$(_get_submodule_path $submodule)
    _check_submodule_path $path
    IFS='/' read -r dir1 dir2 dir3 <<< "$path"
    ln_link="$dir1/$dir2/$module"

    rm $ln_link && \
    git add --all && \
    git commit -m "Removed module $ln_link"
}

remove_submodule() {
    _do_first
    submodule=$1
    path=$(_get_submodule_path $submodule)

    rm -rf "$path/.git" && \
    git submodule deinit -f "$path" && \
    git rm -f "$path" && \
    rm -rf ".git/modules/$path" && \
    rm -rf "$path" && \
    git add --all && \
    git commit -m "Removed submodule $path"
}

# CUSTOM

add_beta_module() {
    # Lowest priority, replace with module in e.g. OCA.
    _add_custom_module "$@" "z-BETA"
}
add_fix_module() {
    # Highest priority, override module in e.g. OCA.
    _add_custom_module "$@" "A-FIX"
}
_add_custom_module() {
    _do_first
    gh_user=$1
    gh_repo=$2
    gh_branch=$3
    module=$4
    dir1=$5
    submodule_name=$(_get_default_submodule_name $dir1 $module)
    submodule_path=$(_get_default_submodule_path $dir1 $module)
    add_submodule $gh_user $gh_repo $gh_branch $submodule_name $submodule_path
    add_module $submodule_name $module $submodule_path
}

remove_beta_module() {
    _remove_custom_module "$@" "z-BETA"
}
remove_fix_module() {
    _remove_custom_module "$@" "A-FIX"
}
_remove_custom_module() {
    _do_first
    submodule=$1
    module=$2
    remove_module $submodule $module
    remove_submodule $submodule
}

# LOW-LEVEL

_do_first() {
    chmod 600 ~/.ssh/id_ed25519
    eval "$(ssh-agent -s)"
    ssh-add ~/.ssh/id_ed25519
    cd $project_root
    git checkout $project_branch
}

_get_url() {
    gh_user=$1
    gh_repo=$2
    echo "git@github.com:$gh_user/$gh_repo.git"
}

_get_default_submodule_name() {
    dir1=$1
    dir2=$2
    echo "$dir1/$dir2"
}

_get_default_submodule_path() {
    dir1=$1
    dir2=$2
    echo "$dir1/$dir2/.$dir2"
}

_get_submodule_path() {
    submodule=$1
    path=$(git config --file $project_root/.gitmodules --get "submodule.${submodule}.path")
    echo "$path"
}

_check_submodule_path() {
    path=$1
    IFS='/' read -r dir1 dir2 dir3 <<< "$path"
    if [[ $dir3 != .* ]]; then
        echo "Error: Submodule path $path: dir3 must begin with a dot" >&2
        exit 1
    fi
}

#########################################
# Use this function to update a single submodule shallowly
# when it was CLONED SHALLOWLY.
#########################################
update_submodule_branch() {
    local path="$1"
    local branch="$2"

    if [ -z "$path" ] || [ -z "$branch" ]; then
        echo "Usage: update_submodule_branch <submodule_path> <branch>"
        return 1
    fi

    echo "==> Updating submodule '$path' to branch '$branch'"

    # Initialize submodule if necessary
    git submodule update --init "$path"

    pushd "$path" > /dev/null || { echo "Failed to enter submodule $path"; return 1; }

    # Commit recorded in superproject
    local commit_sha
    commit_sha=$(git rev-parse HEAD)  # HEAD points to the commit superproject expects

    # Shallow fetch:
    # 1. Tip of the branch (optional, for later --remote updates)
    git fetch --depth=1 origin "$branch" || true

    # 2. The commit recorded by superproject (guaranteed)
    git fetch --depth=1 origin "$commit_sha"

    # Checkout local branch pointing to the superproject commit
    git checkout -B "$branch" "$commit_sha"

    popd > /dev/null
}


#########################################
# Use this function to update all submodules shallowly
# when they were CLONED SHALLOWLY.
#########################################
update_all_submodules_branch() {
    echo "==> Updating all submodules from $project_root/.gitmodules"

    if [ ! -f "$project_root/.gitmodules" ]; then
        echo "Error: $project_root/.gitmodules file not found"
        return 1
    fi

    declare -A submodules_branches
    local path branch

    # Parse $project_root/.gitmodules
    while IFS= read -r line; do
        if [[ $line =~ path[[:space:]]*=[[:space:]]*(.+) ]]; then
            path="${BASH_REMATCH[1]}"
        fi
        if [[ $line =~ branch[[:space:]]*=[[:space:]]*(.+) ]]; then
            branch="${BASH_REMATCH[1]}"
        fi
        # Default branch if none specified
        if [[ -n "$path" && -z "$branch" ]]; then
            branch="master"
        fi
        if [[ -n "$path" && -n "$branch" ]]; then
            submodules_branches["$path"]="$branch"
            path=""
            branch=""
        fi
    done < "$project_root/.gitmodules"

    # Loop over all submodules and update
    for path in "${!submodules_branches[@]}"; do
        update_submodule_branch "$path" "${submodules_branches[$path]}"
    done

    echo "âœ… All submodules updated."
}

###########################################################

if declare -f "$1" > /dev/null; then
    "$1" "${@:2}"
else
    case "$1" in
        all)
            install
            lint
            ;;
        *)
            echo "Unknown command: $1"
            help
            exit 1
            ;;
    esac
fi
